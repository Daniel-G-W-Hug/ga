#pragma once

// author: Daniel Hug, 2024

#include "ga_mvec8_t.hpp"
#include "ga_type_3d.hpp"

////////////////////////////////////////////////////////////////////////////////
// consistent type definitions for easy use
////////////////////////////////////////////////////////////////////////////////

namespace hd::ga {

struct mvec3d_tag {};

////////////////////////////////////////////////////////////////////////////////
// reuse all from MVec8_t and add specific ctors for MVec3d
////////////////////////////////////////////////////////////////////////////////

template <typename T> struct MVec3d : public MVec8_t<T, mvec3d_tag> {

    // default ctor (all grades = 0)
    MVec3d() : MVec8_t<T, mvec3d_tag>() {}

    // assign all components directly
    MVec3d(T s, T x, T y, T z, T yz, T zx, T xy, T ps) :
        MVec8_t<T, mvec3d_tag>(s, x, y, z, yz, zx, xy, ps)
    {
    }

    // floating point type conversion
    template <typename U>
        requires(std::floating_point<U>)
    MVec3d(MVec3d<U> const& v) :
        MVec8_t<U, mvec3d_tag>(v.c0, v.c1, v.c2, v.c3, v.c4, v.c5, v.c6, v.c7)
    {
    }

    // type adjustment
    template <typename U>
        requires(std::floating_point<U>)
    MVec3d(MVec8_t<U, mvec3d_tag> const& v) :
        MVec8_t<U, mvec3d_tag>(v.c0, v.c1, v.c2, v.c3, v.c4, v.c5, v.c6, v.c7)
    {
    }

    // assign a scalar part exclusively (other grades = 0)
    MVec3d(Scalar<T> s) : MVec8_t<T, mvec3d_tag>(s, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) {}

    // assign a vector part exclusively (other grades = 0)
    MVec3d(Vec3d<T> const& v) :
        MVec8_t<T, mvec3d_tag>(0.0, v.x, v.y, v.z, 0.0, 0.0, 0.0, 0.0)
    {
    }

    // assign a bivector part exclusively (other grades = 0)
    MVec3d(BiVec3d<T> const& v) :
        MVec8_t<T, mvec3d_tag>(0.0, 0.0, 0.0, 0.0, v.x, v.y, v.z, 0.0)
    {
    }

    // assign a pseudoscalar part exclusively (other grades = 0)
    MVec3d(PScalar3d<T> ps) :
        MVec8_t<T, mvec3d_tag>(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ps)
    {
    }

    // assign a geometric product resulting from a product of two vectors
    // via dot(v1,v2) and wdg(v1,v2) or via dot(v1,v2) and cmt(v1,v2) directly
    // (other grades = 0)
    MVec3d(Scalar<T> s, BiVec3d<T> const& v) :
        MVec8_t<T, mvec3d_tag>(s, 0.0, 0.0, 0.0, v.x, v.y, v.z, 0.0)
    {
    }

    // assign from a quaternion, i.e. from the even subalgebra
    MVec3d(MVec3d_E<T> const& v) :
        MVec8_t<T, mvec3d_tag>(v.c0, 0.0, 0.0, 0.0, v.c1, v.c2, v.c3, 0.0)
    {
    }

    // assign a geometric product resulting from a product of a vector and a bivector
    MVec3d(Vec3d<T> const& v, PScalar3d<T> ps) :
        MVec8_t<T, mvec3d_tag>(0.0, v.x, v.y, v.z, 0.0, 0.0, 0.0, ps)
    {
    }

    // assign from the uneven subalgebra
    MVec3d(MVec3d_U<T> const& v) :
        MVec8_t<T, mvec3d_tag>(0.0, v.c0, v.c1, v.c2, 0.0, 0.0, 0.0, v.c3)
    {
    }
};

////////////////////////////////////////////////////////////////////////////////
// define grade operations for MVec3d
////////////////////////////////////////////////////////////////////////////////

// returning various grades of a 3d multivector
//
// grade 0: gr0() - scalar
// grade 1: gr1() - vector
// grade 2: gr2() - bivector
// grade 3: gr3() - trivector (= pseudoscalar in 3d)

template <typename T> inline constexpr Scalar<T> gr0(MVec3d<T> const& v)
{
    return Scalar<T>(v.c0);
}

template <typename T> inline constexpr Vec3d<T> gr1(MVec3d<T> const& v)
{
    return Vec3d<T>(v.c1, v.c2, v.c3);
}
template <typename T> inline constexpr BiVec3d<T> gr2(MVec3d<T> const& v)
{
    return BiVec3d<T>(v.c4, v.c5, v.c6);
}

template <typename T> inline constexpr PScalar3d<T> gr3(MVec3d<T> const& v)
{
    return PScalar3d<T>(v.c7);
}

} // namespace hd::ga