#include <cctype>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>

// generated by ChatGPT - does not work, just for illustration

using namespace std;

struct Term {
    string variable;
    double coefficient;

    Term(string var, double coeff) : variable(var), coefficient(coeff) {}
};

// Function to split a string into terms
vector<string> splitTerms(const string& expr)
{
    vector<string> terms;
    string term;
    bool insideParentheses = false;

    for (char ch : expr) {
        if (ch == '(') {
            insideParentheses = true;
        }
        else if (ch == ')') {
            insideParentheses = false;
        }

        // if ((ch == '+' || ch == '-') && !insideParentheses) {
        if ((ch == '+' || ch == '-')) {
            if (!term.empty()) {
                terms.push_back(term);
            }
            term = ch; // Start new term with + or -
        }
        else {
            term += ch;
        }
    }
    if (!term.empty()) {
        terms.push_back(term); // Add the last term
    }

    return terms;
}

// Function to extract terms from the string (e.g., R.c0 * v.x -> Term("v.x", R.c0))
Term parseTerm(const string& termStr)
{
    size_t starPos = termStr.find('*');
    double coefficient = 1.0;
    string variable = "";

    if (starPos != string::npos) {
        string coeffStr = termStr.substr(0, starPos);
        string varStr = termStr.substr(starPos + 2); // skip the " * "

        // coefficient = stod(coeffStr);
        coefficient = 1.0;
        variable = varStr;
    }
    else {
        // Handle cases where there's no '*' (e.g., just a variable like v.x or v.y)
        coefficient = 1.0;
        variable = termStr;
    }

    return Term(variable, coefficient);
}

// Function to parse and group terms
map<string, double> groupTermsByVariable(const string& expr)
{
    map<string, double> groupedTerms;

    // Split the expression into terms
    vector<string> terms = splitTerms(expr);

    // Process each term
    for (const string& term : terms) {
        Term parsedTerm = parseTerm(term);
        groupedTerms[parsedTerm.variable] += parsedTerm.coefficient;
    }

    return groupedTerms;
}

// Function to format and print the simplified expression
void printSimplifiedExpression(const map<string, double>& groupedTerms)
{
    for (const auto& [variable, coeff] : groupedTerms) {
        if (coeff != 0) {
            cout << (coeff > 0 ? "+" : "") << coeff << " * " << variable << " ";
        }
    }
    cout << endl;
}

int main()
{

    try {
        string expr1 =
            "-(R.c0 * v.x - R.c2 * v.z + R.c3 * v.y) * R.c1 - (R.c0 * v.y + R.c1 "
            "* v.z - R.c3 * v.x) * R.c2 - (R.c0 * v.z - R.c1 * v.y + R.c2 * v.x) "
            "* R.c3 + (R.c1 * v.x + R.c2 * v.y + R.c3 * v.z) * R.c0";
        string expr2 =
            "(R.c0 * v.x - R.c2 * v.z + R.c3 * v.y) * R.c0 + (R.c0 * v.y + R.c1 * "
            "v.z - R.c3 * v.x) * R.c3 - (R.c0 * v.z - R.c1 * v.y + R.c2 * v.x) * "
            "R.c2 + (R.c1 * v.x + R.c2 * v.y + R.c3 * v.z) * R.c1";
        string expr3 =
            "-(R.c0 * v.x - R.c2 * v.z + R.c3 * v.y) * R.c3 + (R.c0 * v.y + R.c1 "
            "* v.z - R.c3 * v.x) * R.c0 + (R.c0 * v.z - R.c1 * v.y + R.c2 * v.x) "
            "* R.c1 + (R.c1 * v.x + R.c2 * v.y + R.c3 * v.z) * R.c2";

        map<string, double> result1 = groupTermsByVariable(expr1);
        map<string, double> result2 = groupTermsByVariable(expr2);
        map<string, double> result3 = groupTermsByVariable(expr3);

        cout << "Simplified Expression 1: ";
        printSimplifiedExpression(result1);

        cout << "Simplified Expression 2: ";
        printSimplifiedExpression(result2);

        cout << "Simplified Expression 3: ";
        printSimplifiedExpression(result3);
    }
    catch (std::exception const& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }

    return 0;
}
